
DAO（去中心化自治组织）是一种通过智能合约运行的组织形式，其规则和决策过程通过区块链上的代码来执行。
DAO 的运作是透明的，并且通常由代币持有者共同管理。
零知识证明：不泄漏关键信息或隐私的情况下证明，通常链下生成，链上验证
去中心化域名：基于区块链技术建立的域名，抗审查，用户主权不可篡改

EVM 底层指令，在 Solidity 中通过汇编调用



https://zhuanlan.zhihu.com/p/598587417

DefiLlama平台数据


defi：DEX（去中心化交易所）、借贷、抵押稳定币、流动性质押、

抵押稳定币：MakerDAO、Liquity

流动性质押：Lido

借贷： AAVE、JustLend、Compound Finance、Venus

去中心化交易所：Curve、Uniswap、PancakeSwap、Balancer

流动性挖矿：Convex Finance、

资产管理：InstaDApp


不同赛道的比例：最大的赛道是交易和借贷，交易所、借贷平台、稳定币被称为公链的三板斧，很多新公链都会标配这三种项目；

Uniswap和Curve是交易赛道的龙头，MakerDAO、AAVE和Compound是借贷赛道的龙头。

其中交易赛道又可以分为现货交易和衍生品交易，对比传统金融市场，衍生品交易量是现货交易的10倍以上，
因此dYdX、GMX、Synthetix这类衍生品交易所未来会有非常大的成长空间。



越来越多的DeFi「工具式应用」围绕着单个底层的「超级 DeFi 协议」进行开发，通过辅助其完善更为丰富的高级衍生功能，
从而依托这些个底层的「超级 DeFi 协议」发展壮大，并最终反哺底层的「超级 DeFi 协议」实现更大赋能，
逐步发展出一个个独具特色而又自成体系的「小生态」。



chain list
https://chainid.network/







基于区块链的质押系统要求用户将加密货币锁定在智能合约中，作为参与网络共识或提供服务的抵押，从而获得奖励（如新代币、交易手续费等）。
其本质是权益证明（PoS）机制的延伸

节点质押
用户直接运行验证节点，质押代币参与共识，适合技术能力强的参与者。例如以太坊2.0要求最低质押32 ETH。
优势：高收益（无佣金）、直接参与治理；风险：高资金门槛、技术维护成本。

流动性质押（Liquid Staking）
通过协议（如Lido）将质押代币转换为衍生代币（如stETH），保持流动性。用户可同时参与质押和DeFi活动（如借贷、交易）。
应用场景：解决传统质押的流动性问题，适用于高频交易者。

委托质押（DPoS）
普通用户将代币委托给专业节点，由节点代理验证和收益分配。例如EOS的超级节点选举。
优势：低门槛、便捷；风险：依赖节点可靠性。

跨链质押
通过跨链桥将资产质押到其他链（如以太坊质押BTC获取Polygon收益），打破生态壁垒。
技术难点：需确保跨链数据一致性与安全性。









Position（头寸） 是流动性提供者（LP）在特定价格区间内提供流动性的核心管理单元
通过非同质化代币（NFT）形式唯一标识每个 LP 的流动性分配策略，并记录与手续费、流动性变化相关的关键数据









------------------------------------------------------------------------------------
------------------------------------------------------------------------------------
------------------------------------------------------------------------------------
------------------------------------------------------------------------------------
------------------------------------------------------------------------------------


触发fallback() 还是 receive()?
           接收ETH
              |
         msg.data是空？
            /  \
          是    否
          /      \
receive()存在?   fallback()
        / \
       是  否
      /     \
receive()   fallback()



一个合约最多有一个receive()函数,函数不能有任何的参数，不能返回任何值，必须包含external和payable。
fallback()声明时不需要function关键字，必须由external修饰，一般也会用payable修饰
fallback()会在调用合约不存在的函数时被触发。可用于接收ETH，也可以用于代理合约proxy contract

eth 和  erc20、erc721 不同，eth是原生代币， 
usdt usdc  eurt 这些都是  erc20，

继承：提高代码复用率 
组合：解耦，模块动态组合（替代多继承）
接口：定义交互规范（不同合约间行为协议），隐藏实现细节 除函数、事件、错误，不能有状态变量或构造函数  external 和 virtual， 默认 virtual， 不能实现任何函数
抽象：提供默认的行为模板，含未实现函数（部分实现）
库  ：用于封装常用函数的代码模块，提高代码的维护性和安全性（数学运算、数组操作等），由函数组成，不能定义状态变量，不能修改状态信息，没有独立上下文
      如果库中都是 internal 那么编译器会将代码嵌入到调用合约，这个库就是内嵌库

using xxx for address：将库函数绑定到特定类型
address add;  add.fdfds();


继承时  this ：
A is B ， 那么如果A调用了B的方法，在B方法中 有  address(this)  那么地址就是A的地址
组合时  this ：
如上： 此时 地址应该是B的地址，不是A的地址







在常见的DApp应用中，往往是 ERC-20/ERC-721/ERC-1155 作为核心资产标准，再叠加 ERC-2612、EIP-712、ERC-1271、ERC-2981 等扩展来增强体验和兼容性。

erc20:
name、symbol、decimals、totalSupply()、
transfer(address to, uint256 value) bool、
transferFrom(address, address, value)、 代表a行使转账
allowance(address, address) returns(uint256)、
approve(address to, uint256) onlyOwner、

event: transfer, approvl

require() 函数来检查代币余额是否充足，以及适当管理交易的状态变化来防止双重花费
ERC20 的安全性考量有哪些?
使用 SafeMath 防止整数溢出。
防止 approve() 和 transferFrom() 的双花漏洞，如先将批准数量设置为 0，再更新新的授权数量。
确保合约不会意外接收和锁定代币（如增加 withdraw() 函数，允许错误转入的代币退回）。
确保 transfer() 和 transferFrom() 在代币余额不足时会正确回滚交易

erc721:


erc165: ERC165主要是用来检测智能合约是否实现了特定的接口
interface IERC165 {
    function supportsInterface(bytes4 interfaceId) external view returns (bool);
}

contract ERC165 is IERC165 {
    mapping(bytes4 => bool) private _supportedInterfaces;
    constructor() {
        _registerInterface(type(IERC165).interfaceId);
    }
    function _registerInterface(bytes4 interfaceId) internal virtual {
        require(interfaceId != 0xffffffff, "ERC165: invalid interface id");
        _supportedInterfaces[interfaceId] = true;
    }
    function supportsInterface(bytes4 interfaceId)  public  view  virtual  override  returns (bool)  {
        return _supportedInterfaces[interfaceId];
    }
}
contract MyMultiToken is ERC165, IERC20Example, IERC721Example, IMintable {
    constructor() {
        _registerInterface(type(IERC20Example).interfaceId); 
        _registerInterface(this.myFunction.selector);
    }

    function ttt() public pure returns (bytes4) {
        // return type(IERC20Example).interfaceId;  //  0xd9a51e8a  true     明确注册的才是true
        // return this.mint.selector;   // 0x40c10f19  false
        return IERC20Example.transfer.selector;   // 0xa9059cbb  false
    }
}


ERC777 是 ERC20 的升级版，增加了诸如发送钩子、操作员（operator）功能和增强的代币安全性
如果使用 ERC777 的 send 方法，并且接收者是合约，那么该合约必须实现 IERC777Recipient 接口（即具有 tokensReceived 方法），否则转账会失败。
而 ERC20 的 transfer 方法则没有这个要求，这也是 ERC777 为了增强安全性而设计的，防止代币被意外转入无法处理代币的合约中。
ERC777:  
    1. 带数据的转账; 
    2. 合约交互,没有实现 tokensReceived，交易会回滚; 
    3. 条件转账 // ERC777 可以在接收时验证条件 token.send(to, amount, conditions);
ERC777 的钩子函数（Hooks）并非直接由 EVM 约定，而是通过 ERC1820 注册表标准 实现的接口调用机制    



ERC-2612是ERC-20的扩展基于 ERC-712 的签名标准，专注于代币授权场景，引入了permit函数，允许链下签名授权，解决了传统ERC-20需要两笔交易的问题
传统 ERC-20 授权需两步操作：
    调用 approve(spender, amount)授权。
    第三方调用 transferFrom执行转账。

    高成本：两笔交易增加 Gas 费用。
    低效交互：需钱包多次确认。
    安全风险：无限授权可能被滥用

ERC-2612 的改进：
    单笔交易完成授权：通过签名直接触发授权，减少链上交互。
    灵活性：可自定义授权金额和有效期（通过 deadline）

function permit(
    // approve 的参数
    address owner,
    address spender,
    uint256 value,
    /* -------------------------- */
    uint256 deadline,  // 签名有效截止时间
    uint8 v,
    bytes32 r,
    bytes32 s
) external;    

ERC-2612 通过链下签名机制，解决了 ERC-20 授权流程中的高成本和低效问题，成为现代 DeFi 基础设施的核心组件。
    其设计兼顾安全性与用户体验，被广泛集成至主流协议中

应用场景：
DeFi 协议集成：如 Uniswap、Aave 等，用户可直接授权协议操作代币，无需预付 Gas。
批量操作优化：通过多次调用 permit授权多个代币，简化复杂交易流程。
钱包与 DApp 交互：提升用户体验，减少链上确认步骤。





EIP-712 是以太坊生态中用于类型化结构化数据签名的核心标准，通过将链下数据编码为可验证的哈希值，解决了传统签名不透明、易被滥用的痛点

透明化签名内容：将用户签署的十六进制哈希转换为人类可读的结构化数据（如转账金额、接收地址等）。
提升安全性：通过类型校验和域分隔符防止数据篡改和重放攻击。
降低 Gas 成本：支持链下签名后上链验证，减少链上交易次数

应用场景：
代币授权（ERC-20 Permit）：用户通过签名授权代币转移，无需预付 Gas。
NFT 白名单：签名授权铸造或交易权限。
DeFi 交易：支持链下挂单（如 Uniswap 的限价单）。
DAO 治理：链下投票签名（如 Snapshot）

EIP-712 通过结构化数据编码和域隔离机制，解决了链下签名中的透明性与安全性问题，成为 DeFi、NFT 等场景的基础设施。
    其设计思想深刻影响了后续标准（如 ERC-2612）的发展







ERC-1155 是以太坊生态中用于多代币管理的标准化协议，允许单个智能合约同时处理同质化、非同质化及半同质化代币，显著提升代币交互效率并降低成本
为复杂代币交互提供了标准化解决方案，未来在跨链资产管理和元宇宙经济中潜力巨大

ERC-1155解决了部署效率低和操作效率低的问题，通过批量操作减少交易次数和Gas费用 

应用场景
区块链游戏：管理游戏内道具（如武器、皮肤），支持批量交易与动态属性。
数字收藏品平台：同时发行限量版艺术品（NFT）和批量数字商品（同质化代币）。
供应链与票据系统：跟踪不同类型凭证（如发票、许可证）的流通状态

通过 safeBatchTransferFrom一次性转移多个代币类型（如同时转 100 USDT + 1 个 NFT + 50 游戏金币），仅需一次链上交易
批量操作具备原子性（All-or-Nothing），要么全部成功，要么全部失败，无需手动处理中间状态
通过 uri(id)函数为每个代币 ID 动态关联元数据（如 JSON 文件），支持批量更新与复用
相同元数据可被多个代币 ID 共享，修改元数据无需逐个代币操作

让项目变得复杂难以管理和维护，审计周期和成本增高
生态兼容不足，dapp和钱包支持不完善（有的支持有的不支持）影响体验，现有项目无法兼容（如完全按照erc20、或erc721设计的项目）
现有的中心化交易所通常是只支持erc20，改造困难，是的erc1155难以在交易所上市
对于有成千上万个代币ID的项目管理和维护都非常复杂
半同质化定位不清晰，增加了显示复杂

如果你的项目是游戏、数字收藏品平台，需要大量、频繁地转移多种道具和资产，那么 ERC1155 在 Gas 费和批量操作上的优势将远远超过其劣势。
如果你的项目是发行独立的、高价值的艺术品，或者需要与现有 DeFi 生态深度集成并上架中心化交易所，那么 ERC721 或 ERC20 可能是更安全、更兼容的选择






ERC-2981是一个NFT版税标准，旨在让创作者在NFT的二次销售中获得版税
ERC-2981 通过 标准化查询接口 和 动态版税模型，解决了 NFT 二次销售中创作者收益分配的难题。【市场自愿采用】



ERC-1271 是以太坊生态中用于 智能合约签名验证的标准化协议，允许智能合约钱包（SCA）通过自定义逻辑验证签名，从而实现与外部拥有账户（EOA）同等的交互能力
漏洞根源：未绑定合约地址，同一签名可被多个 SCA 重放





ERC-3643 是以太坊区块链上的一种新兴代币标准，专注于现实世界资产（RWA）的代币化。

代币标准: 定义RWA代币的行为（如转账限制、收益分配）ERC-3643, ERC-1400, ERC-3475, ERC-1155



合约创建加盐： CREATE2
pool = address(new Pool{salt: salt}())  // 如此构造就不能用合约构造传参，因为那样会导致新地址的initcode发生变化，因此需要使用一个 变量来报存 pool 构造的参数
地址可预测性：你可以在部署之前就计算出合约的地址，这在设计某些复杂系统（如状态通道、HTLC、元交易等）时极其重要。
不依赖 nonce：不像 CREATE那样依赖账户的 nonce（交易计数），因此地址不随部署顺序变动。【keccak256(rlp([creator_address, nonce]))】
更灵活的部署逻辑：可以基于某些参数动态决定合约地址，实现更复杂的逻辑。

0xff： EVM 定死的字节前缀，用于区分 CREATE 和 CREATE2
address = keccak256( 0xff ++ deployer_address ++ salt ++ keccak256(initcode) )[12:]

计算合约地址：
bytes32 hash = keccak256( abi.encodePacked(bytes1(0xff), deployer, salt, keccak256(initcode)) );
address = address(uint160(uint256(hash)));    // 取后 20 字节作为地址

实际应用：
工厂模式（Factory Contract）：一个主合约通过 CREATE2 部署多个子合约，每个子合约地址由 salt 控制。
    如果你是一个工厂合约，负责帮别人部署合约，使用 CREATE2，你可以：
    让用户传入一个 salt
    你就能告诉用户：“你用这个 salt，将来合约会部署在某某地址”
    用户可以提前验证这个地址是否符合他们的预期
    甚至可以提前授权、签名、交互

状态通道 / HTLC（哈希时间锁合约）：预先计算合约地址，用于锁定资产。
    在这些应用中，双方需要在某个地址上锁定资金，这个地址必须事先知道，这样双方才能签名承诺往那个地址发钱。
    如果你用普通的 CREATE，你无法提前知道合约地址，也就无法提前让对方签名和交互。
    但用 CREATE2，你可以根据用户地址或交易 ID 等信息，提前计算出合约地址，然后让参与者提前签名和准备。

NFT Mint 合约按需部署：根据用户地址或 token ID 动态部署合约。
    你可能希望：
    每个用户第一次使用时，自动为他部署一个个性化的合约（比如 NFT Vault、游戏角色、用户数据合约）
    但你又想 提前知道这个合约会部署在哪里，这样你可以提前初始化 UI、权限、链接等。
    通过 CREATE2+ 某个用户相关的 salt（比如用户地址），你就可以做到：
    只要你提供你的地址，我就知道为你准备的合约部署在哪个地址，甚至可以提前为其分配资源。

可升级模式 / 代理合约初始化：结合代理模式，动态部署逻辑合约。
去中心化交易所的流动性池：Uniswap V2 就是使用 CREATE2 来确保交易对地址是确定的。
    Uniswap V2 在创建交易对（比如 ETH/USDC）时，交易对的合约地址必须是确定的，这样其他系统（比如路由、前端）才能准确地与它交互。
    Uniswap 就是使用 CREATE2，根据两个 Token 的地址，计算出这个交易对合约会部署在哪个地址，然后确保大家都用这个地址去访问。
    如果没有地址可预测性，每次创建交易对都要“尝试”部署并查找地址，那会非常麻烦且不可靠。

传统的 CREATE方式就像：只有当用户到了现场、坐下来，你才给他安排座位，而且座位是按他到达的顺序排的，你没法提前告诉他坐哪里。
而 CREATE2就像是：你提前制定好规则：只要用户报上他的名字（salt），你就知道他会坐在哪个位置（地址）。
你不用等他真的到场，就可以提前打印好他的门票，上面写明了座位号。
这就是 地址可预测性 的直观意义！

传统的 CREATE 每次都会生成不同的 address
新地址 = keccak256(发送者地址 + Nonce)
CREATE2 如果相同的 slot 那么第二次部署会失败


以太坊 调用合约是基于目标地址来确定应该调用哪个合约的



什么是nft，
erc721 协议 
交易方式3种









--------------------------------------------------------------
基本类型（如uint256, bool, address等）每个占用一个存储槽。
动态数组（如PoolBaseInfo[]）在声明的位置存储数组长度，而数组元素则存储在通过Keccak-256哈希计算得到的槽开始的位置。
映射（mapping）则不同，映射的键不存储实际数据，而是通过键的哈希来定位值的位置。具体来说，映射中键k对应的值存储在 keccak256(h(k) . p) 的位置，其中p是映射所在的存储槽，h是一个函数，根据键的类型不同而不同（对于值类型，就是直接填充到32字节；对于字符串或字节，则是Keccak-256哈希）。
结构体（struct）在存储中会依次存放其每个成员，根据成员的类型占用一个或多个存储槽。
常量（constant）和** immutable** 变量不占用存储槽，它们的值直接嵌入在合约字节码中。


从 storage 中加载变量的值 
// 源代码
uint256 amount = minAmount;
// 底层相当于
uint256 amount = sload(0);  // 从存储槽 0 读取数据

// 源代码
minAmount = 200e18;
// 底层相当于
sstore(0, 200e18);  // 将数据存储到槽 0


// 数组长度存储在槽 7：sload(7) 返回数组长度
// 数组元素存储在：keccak256(7) + index
PoolBaseInfo[] public poolBaseInfo;  // slot 7
// 访问 poolBaseInfo[0]
bytes32 baseSlot = keccak256(abi.encode(7));  // 计算起始位置
PoolBaseInfo memory firstPool = readStruct(baseSlot);  // 读取结构体
// 访问 poolBaseInfo[1]
PoolBaseInfo memory secondPool = readStruct(baseSlot + 1);
结构体存储是紧密相连的依次下移


// 访问 poolBaseInfo[0]
bytes32 baseSlot = keccak256(abi.encode(7)); // 起始位置
// 结构体字段位置：
// poolBaseInfo[0].settleTime    -> baseSlot + 0
// poolBaseInfo[0].endTime       -> baseSlot + 1
// poolBaseInfo[0].interestRate  -> baseSlot + 2
// ...

// 访问 poolBaseInfo[1]
// poolBaseInfo[1].settleTime    -> baseSlot + 13 (因为每个结构体占13个槽)
// poolBaseInfo[1].endTime       -> baseSlot + 14






mapping (address => mapping (uint256 => BorrowInfo)) public userBorrowInfo;  // slot 9
// 访问 userBorrowInfo[userAddr][poolId]
bytes32 slot = keccak256(      abi.encode(    poolId,  keccak256( abi.encode(userAddr, uint256(9)) )     )      );
BorrowInfo memory info = readStruct(slot);





struct BorrowInfo {
    uint256 stakeAmount;    // 32字节
    uint256 refundAmount;   // 32字节  
    bool hasNoRefund;       // 1字节
    bool hasNoClaim;        // 1字节
}

BorrowInfo public xxxx;   //  slot 10

// 源代码 
uint256 amount = bb.stakeAmount;
// 底层实现
assembly {
    let value := sload(10)  // 直接从 slot 10 读取
    // 将 value 存储到内存返回
}

// 源代码  
uint256 refund = bb.refundAmount;

// 底层实现
assembly {
    let value := sload(11)  // 从 slot 11 读取
}

// 源代码
bb.hasNoRefund = true;

// 底层实现
assembly {
    let currentPacked := sload(12)      // 读取当前值  布尔 占1位 会打包到一起
    let newPacked := or(currentPacked, 0x01)  // 设置第0位为1    0x02
    sstore(12, newPacked)               // 写回 slot 12
}