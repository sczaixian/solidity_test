
DAO（去中心化自治组织）是一种通过智能合约运行的组织形式，其规则和决策过程通过区块链上的代码来执行。
DAO 的运作是透明的，并且通常由代币持有者共同管理。
零知识证明：不泄漏关键信息或隐私的情况下证明，通常链下生成，链上验证
去中心化域名：基于区块链技术建立的域名，抗审查，用户主权不可篡改

















------------------------------------------------------------------------------------
------------------------------------------------------------------------------------
------------------------------------------------------------------------------------
------------------------------------------------------------------------------------
------------------------------------------------------------------------------------


触发fallback() 还是 receive()?
           接收ETH
              |
         msg.data是空？
            /  \
          是    否
          /      \
receive()存在?   fallback()
        / \
       是  否
      /     \
receive()   fallback()



一个合约最多有一个receive()函数,函数不能有任何的参数，不能返回任何值，必须包含external和payable。
fallback()声明时不需要function关键字，必须由external修饰，一般也会用payable修饰


eth 和  erc20、erc721 不同，eth是原生代币， 
usdt usdc  eurt 这些都是  erc20，

继承：提高代码复用率
组合：解耦，模块动态组合（替代多继承）
接口：定义交互规范（不同合约间行为协议），隐藏实现细节 除函数、事件、错误，不能有状态变量或构造函数  external 和 virtual， 默认 virtual， 不能实现任何函数
抽象：提供默认的行为模板，含未实现函数（部分实现）
库  ：用于封装常用函数的代码模块，提高代码的维护性和安全性（数学运算、数组操作等），由函数组成，不能定义状态变量，不能修改状态信息，没有独立上下文
      如果库中都是 internal 那么编译器会将代码嵌入到调用合约，这个库就是内嵌库

using xxx for address：将库函数绑定到特定类型
address add;  add.fdfds();








在常见的DApp应用中，往往是 ERC-20/ERC-721/ERC-1155 作为核心资产标准，再叠加 ERC-2612、EIP-712、ERC-1271、ERC-2981 等扩展来增强体验和兼容性。

erc20:
name、symbol、decimals、totalSupply()、
transfer(address to, uint256 value) bool、
transferFrom(address, address, value)、 代表a行使转账
allowance(address, address) returns(uint256)、
approve(address to, uint256) onlyOwner、

event: transfer, approvl

require() 函数来检查代币余额是否充足，以及适当管理交易的状态变化来防止双重花费
ERC20 的安全性考量有哪些?
使用 SafeMath 防止整数溢出。
防止 approve() 和 transferFrom() 的双花漏洞，如先将批准数量设置为 0，再更新新的授权数量。
确保合约不会意外接收和锁定代币（如增加 withdraw() 函数，允许错误转入的代币退回）。
确保 transfer() 和 transferFrom() 在代币余额不足时会正确回滚交易

erc721:


erc165:
interface IERC165 {
    function supportsInterface(bytes4 interfaceId) external view returns (bool);
}

contract ERC165 is IERC165 {
    mapping(bytes4 => bool) private _supportedInterfaces;
    constructor() {
        _registerInterface(type(IERC165).interfaceId);
    }
    function _registerInterface(bytes4 interfaceId) internal virtual {
        require(interfaceId != 0xffffffff, "ERC165: invalid interface id");
        _supportedInterfaces[interfaceId] = true;
    }
    function supportsInterface(bytes4 interfaceId)  public  view  virtual  override  returns (bool)  {
        return _supportedInterfaces[interfaceId];
    }
}
contract MyMultiToken is ERC165, IERC20Example, IERC721Example, IMintable {
    constructor() {
        _registerInterface(type(IERC20Example).interfaceId); 
        _registerInterface(this.myFunction.selector);
    }

    function ttt() public pure returns (bytes4) {
        // return type(IERC20Example).interfaceId;  //  0xd9a51e8a  true     明确注册的才是true
        // return this.mint.selector;   // 0x40c10f19  false
        return IERC20Example.transfer.selector;   // 0xa9059cbb  false
    }
}


ERC777 是 ERC20 的升级版，增加了诸如发送钩子、操作员功能和增强的代币安全性
如果使用 ERC777 的 send 方法，并且接收者是合约，那么该合约必须实现 IERC777Recipient 接口（即具有 tokensReceived 方法），否则转账会失败。
而 ERC20 的 transfer 方法则没有这个要求，这也是 ERC777 为了增强安全性而设计的，防止代币被意外转入无法处理代币的合约中。
ERC777:  
    1. 带数据的转账; 
    2. 合约交互,没有实现 tokensReceived，交易会回滚; 
    3. 条件转账 // ERC777 可以在接收时验证条件 token.send(to, amount, conditions);
ERC777 的钩子函数（Hooks）并非直接由 EVM 约定，而是通过 ​​ERC1820 注册表标准​​ 实现的接口调用机制    



ERC-2612是ERC-20的扩展，引入了permit函数，允许链下签名授权，解决了传统ERC-20需要两笔交易的问题
传统 ERC-20 授权需两步操作：
    调用 approve(spender, amount)授权。
    第三方调用 transferFrom执行转账。

    高成本​​：两笔交易增加 Gas 费用。
    ​​低效交互​​：需钱包多次确认。
    ​​安全风险​​：无限授权可能被滥用

ERC-2612 的改进​​：
    ​​单笔交易完成授权​​：通过签名直接触发授权，减少链上交互。
    ​​灵活性​​：可自定义授权金额和有效期（通过 deadline）

function permit(
    // approve 的参数
    address owner,
    address spender,
    uint256 value,
    /* -------------------------- */
    uint256 deadline,  // 签名有效截止时间
    uint8 v,
    bytes32 r,
    bytes32 s
) external;    

ERC-2612 通过链下签名机制，解决了 ERC-20 授权流程中的高成本和低效问题，成为现代 DeFi 基础设施的核心组件。
    其设计兼顾安全性与用户体验，被广泛集成至主流协议中

应用场景：
DeFi 协议集成​​：如 Uniswap、Aave 等，用户可直接授权协议操作代币，无需预付 Gas。
​​批量操作优化​​：通过多次调用 permit授权多个代币，简化复杂交易流程。
​​钱包与 DApp 交互​​：提升用户体验，减少链上确认步骤。

ERC-2612 基于 ERC-712 的签名标准，专注于代币授权场景



EIP-712 是以太坊生态中用于​​类型化结构化数据签名​​的核心标准，通过将链下数据编码为可验证的哈希值，解决了传统签名不透明、易被滥用的痛点

透明化签名内容​​：将用户签署的十六进制哈希转换为人类可读的结构化数据（如转账金额、接收地址等）。
​​提升安全性​​：通过类型校验和域分隔符防止数据篡改和重放攻击。
​​降低 Gas 成本​​：支持链下签名后上链验证，减少链上交易次数

应用场景：
代币授权（ERC-20 Permit）​​：用户通过签名授权代币转移，无需预付 Gas。
​​NFT 白名单​​：签名授权铸造或交易权限。
​​DeFi 交易​​：支持链下挂单（如 Uniswap 的限价单）。
​​DAO 治理​​：链下投票签名（如 Snapshot）

EIP-712 通过​​结构化数据编码​​和​​域隔离机制​​，解决了链下签名中的透明性与安全性问题，成为 DeFi、NFT 等场景的基础设施。
    其设计思想深刻影响了后续标准（如 ERC-2612）的发展







ERC-1155 是以太坊生态中用于​​多代币管理的标准化协议​​，允许单个智能合约同时处理同质化、非同质化及半同质化代币，显著提升代币交互效率并降低成本
为复杂代币交互提供了标准化解决方案，未来在跨链资产管理和元宇宙经济中潜力巨大

ERC-1155解决了部署效率低和操作效率低的问题，通过批量操作减少交易次数和Gas费用 

应用场景
区块链游戏​​：管理游戏内道具（如武器、皮肤），支持批量交易与动态属性。
​​数字收藏品平台​​：同时发行限量版艺术品（NFT）和批量数字商品（同质化代币）。
​​供应链与票据系统​​：跟踪不同类型凭证（如发票、许可证）的流通状态

通过 safeBatchTransferFrom一次性转移多个代币类型（如同时转 100 USDT + 1 个 NFT + 50 游戏金币），仅需一次链上交易
批量操作具备原子性（All-or-Nothing），要么全部成功，要么全部失败，无需手动处理中间状态
通过 uri(id)函数为每个代币 ID 动态关联元数据（如 JSON 文件），支持批量更新与复用
相同元数据可被多个代币 ID 共享，修改元数据无需逐个代币操作

让项目变得复杂难以管理和维护，审计周期和成本增高
生态兼容不足，dapp和钱包支持不完善（有的支持有的不支持）影响体验，现有项目无法兼容（如完全按照erc20、或erc721设计的项目）
现有的中心化交易所通常是只支持erc20，改造困难，是的erc1155难以在交易所上市
对于有成千上万个代币ID的项目管理和维护都非常复杂
半同质化定位不清晰，增加了显示复杂

如果你的项目是游戏、数字收藏品平台，需要大量、频繁地转移多种道具和资产，那么 ERC1155 在 Gas 费和批量操作上的优势将远远超过其劣势。
如果你的项目是发行独立的、高价值的艺术品，或者需要与现有 DeFi 生态深度集成并上架中心化交易所，那么 ERC721 或 ERC20 可能是更安全、更兼容的选择






ERC-2981是一个NFT版税标准，旨在让创作者在NFT的二次销售中获得版税
ERC-2981 通过 ​​标准化查询接口​​ 和 ​​动态版税模型​​，解决了 NFT 二次销售中创作者收益分配的难题。【市场自愿采用】



ERC-1271 是以太坊生态中用于 ​​智能合约签名验证的标准化协议​​，允许智能合约钱包（SCA）通过自定义逻辑验证签名，从而实现与外部拥有账户（EOA）同等的交互能力
漏洞根源​​：未绑定合约地址，同一签名可被多个 SCA 重放


