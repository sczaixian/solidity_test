




gas:

indexed ----  375
uint256 ----  16





IPFS
https://docs.ipfs.tech/install/ipfs-desktop/#windows


    预言机：输入预言机（链下往链上送数据）；输出预言机；计算预言机（链下执行计算任务）

    预言机是指获取、验证外部信息（即存储在链下的信息）并将外部信息传送给在区块链上运行的智能合约的应用程序
    主要解决不确定性交易达成共识问题

链上获得链下的数据或信息

提交交易，广播交易，达成共识


多节点预言机网络 DON（decentralized oracle network） 

去中心化的预言机网络


线下数据 --> data providers ---> DON ---> transmit ---> data feed contract(喂价合约) <--- 通过函数名和地址获取相应数据

链上 通过  aggregator（聚合合约）收取 链下数据  <--- 代理合约读取聚合合约  <-----  链上合约 读取代理

预言机合约是预言机服务的链上部分。 它侦听其他合约的数据请求，将数据查询转送到预言机节点，并将返回的数据广播到客户端合约。
它公开了一些函数，客户端合约在发出数据请求时调用它们


coin : 独立链，价值存储和支付；创建成本高，多属商品，用底层“燃料”
token：寄生链（如以太坊），多功能（治理/资产映射/服务访问），创建成本低，可能属性：如证券，属于应用层“工具”










npx hardhat --init

npx hardhat  查看帮助

编译：
npx hardhat build

测试：
npx hardhat test solidity
 文件包括 contract 下面的 .t.sol 文件  和  test 文件夹下的索引 .sol文件

npx hardhat test nodejs


npx hardhat run scripts/send-op-tx.ts

npx hardhat ignition deploy ignition/modules/Counter.ts


部署一般都用 ethers.js  // 文档：https://docs.ethers.org/v6/api/











npm install @openzeppelin/contracts --save-dev
npm install @chainlink/contracts


hardhat-config
sepolia
url:  alchemy  infura  quickNode

alchemy.com




npm update --save-dev hardhat @nomicfoundation/hardhat-verify




npm install @nomiclabs/hardhat-etherscan dotenv --save-dev


运行测试 gas 消耗量
npm install --save-dev hardhat-gas-reporter




-D  是 --save-dev 的简写
npm install -D hardhat-deploy




www.infura.io/faucet/sepolia
test git
0dcf1761eeb2457fb9412f9c4bf59642
https://mainnet.infura.io/v3/0dcf1761eeb2457fb9412f9c4bf59642


curl --url https://mainnet.infura.io/v3/0dcf1761eeb2457fb9412f9c4bf59642 \
  -X POST \
  -H "Content-Type: application/json" \
  -d '{"jsonrpc":"2.0","method":"eth_blockNumber","params":[],"id":1}'




decf550fcc469204df8d024977ad887c888a3164b0977f588ae645d3786b4511

https://dashboard.alchemy.com/?a=index
API key: RmsPYhly5O6-XH8UdmqCQ
https://eth-sepolia.g.alchemy.com/v2/RmsPYhly5O6-XH8UdmqCQ
curl 'https://eth-sepolia.g.alchemy.com/v2/RmsPYhly5O6-XH8UdmqCQ/getNFTs/?owner=vitalik.eth'




https://etherscan.io/apidashboard  apikey

TZ1JWZAT8XK1M8V4JIVD2XJGHU93GRHQ86





0x751599F0a9069D95062edb35F0078cd02BA66cC9





同质化代币就像“标准化货币”，每个代币完全一样，可以互相替换，且能分割成更小的单位
主要用于支付、交易、储蓄等金融场景，类似传统货币。

非同质化代币是“独一无二的数字资产”，每个代币不可互换，且通常不可分割
有独特标识（如编号、元数据），无法被复制或替换。
艺术品收藏、游戏资产、身份认证、版权管理等需要唯一性的场景



要明白 coin  和 token 他们的本质区别
coin ， 价值载体， 
token， 在 coin 的基础上的衍生产物

技术实现
用途
发行方式




开发者部署智能合约时，合约的​​字节码（编译后的代码）​​会通过一笔交易被打包到一个区块中，并永久存储在链上
状态更新分散在所有相关区块
智能合约的代码​​不会持续主动运行​​，而是处于“休眠”状态，直到有人通过交易调用它
通过合约地址定位定位调用





go与 以太坊、比特币、solana这三个交互


-----------------------------solidity 语法相关----------------------------------



// 持币分红实现
function distributeDividends() public {
    uint256 contractBalance = address(this).balance;
    for (uint256 i = 0; i < shareholders.length; i++) {
        address shareholder = shareholders[i];
        uint256 share = balanceOf(shareholder) * contractBalance / totalSupply();
        payable(shareholder).transfer(share);
    }
}

在分发以太币时使用`transfer`函数，虽然`transfer`有2300gas的限制，可以防止重入攻击
循环次数限制：如果股东数量非常多，循环可能会消耗超过区块gas上限的gas，导致交易失败。这在Solidity中是一个常见问题，因为循环gas成本会随着循环次数增加而增加。
状态变量修改：在循环中对外部地址进行转账操作，如果某个地址是合约地址且其fallback函数消耗大量gas，或者故意使转账失败，则会导致整个分红操作回滚。
精度问题：在计算份额时，使用`balanceOf(shareholder) * contractBalance / totalSupply()`，如果`contractBalance`很小，而`totalSupply`很大，则可能会因为整数除法的截断导致一些股东分到的数量为0
快照问题：这个函数没有使用快照机制，如果在分红过程中有转账操作，会导致持币比例变化，从而影响分红的公平性。
权限控制：这个函数是`public`的，意味着任何人都可以调用它，可能会被恶意利用（例如，频繁调用消耗gas，或者在其他不合时宜的时候调用）



 -------------------- 修改 使用拉取模式而不是推送模式 让股东自己领取 ----------------------
mapping(address => uint256) public dividends;

function distributeDividends() public {
    uint256 contractBalance = address(this).balance;
    for (uint256 i = 0; i < shareholders.length; i++) {
        address shareholder = shareholders[i];
        uint256 share = balanceOf(shareholder) * contractBalance / totalSupply();
        dividends[shareholder] += share;
    }
}

function claimDividend() public {
    uint256 amount = dividends[msg.sender];
    require(amount > 0, "No dividends available");
    dividends[msg.sender] = 0;
    payable(msg.sender).transfer(amount);
}


------------------- 可以采用分配发送 每一轮发多少个 -----------------
uint256 public currentIndex;

function distributeDividends(uint256 batchSize) public {
    uint256 contractBalance = address(this).balance;
    uint256 endIndex = Math.min(currentIndex + batchSize, shareholders.length);
    
    for (uint256 i = currentIndex; i < endIndex; i++) {
        address shareholder = shareholders[i];
        uint256 share = balanceOf(shareholder) * contractBalance / totalSupply();
        payable(shareholder).transfer(share);
    }
    
    currentIndex = endIndex;
    if (currentIndex >= shareholders.length) {
        currentIndex = 0; // 重置索引，完成一轮分红
    }
}



// 在分红前先记录每个地址的余额快照
mapping(address => uint256) public snapshotBalance;
uint256 public snapshotTotalSupply;

function takeSnapshot() public {
    for (uint256 i = 0; i < shareholders.length; i++) {
        address shareholder = shareholders[i];
        snapshotBalance[shareholder] = balanceOf(shareholder);
    }
    snapshotTotalSupply = totalSupply();
}









----------------------- 代理合约 ----------------------------

// 代理合约核心逻辑
contract TransparentProxy {
    address private _implementation;   //  本合约要 代理的地址
    address private _admin;

    constructor(address logic) {
        _implementation = logic;
        _admin = msg.sender;
    }
    // 当合约没有匹配到函数前面会执行这个函数
    fallback() external payable {
        require(msg.sender != _admin, "Admin cannot call implementation");
        address impl = _implementation;
        assembly {
            // 当用户调用代理合约时， 调用中包含的说有信息被编码并存储在一个叫做 calldata 的特殊只读区域中
            // calldatacopy(a, b, size)  从 b 位置 搬到 a 位置，总共搬 size 个
            calldatacopy(0, 0, calldatasize())  // 将用户调用的数据复制出来
            // delegatecall 将数据原封不动的发给 impl 
            // let result 捕获的是 delegatecall本身执行的成功还是失败（1true；0false）
            // let result := delegatecall(
            //     gas(),        // 参数1: 发送的gas
            //     impl,         // 参数2: 目标合约地址
            //     0,            // 参数3: 输入数据在内存中的【起始偏移量】
            //     calldatasize(), // 参数4: 输入数据的【大小】
            //     0,            // 参数5: 输出数据在内存中的【起始偏移量】
            //     0             // 参数6: 输出数据【预留空间的大小】
            // )
            let result := delegatecall(gas(), impl, 0, calldatasize(), 0, 0)
            // 成功：返回值会被存储在 EVM 的返回数据缓冲区 (returndata buffer) 中
            // 将缓冲区中的数据复制到内存
            returndatacopy(0, 0, returndatasize())
            if iszero(result) {   // 返回0表示失败
              // 之前执行了 returndatacopy， 现在需要回滚
              revert(0, returndatasize()) 
            }
            // 将内存中的返回值返回给最初调用代理合约的地址
            return(0, returndatasize())
        }
    }
}

























-----------------------------js  ts 语法相关----------------------------------
// 立即执行函数
;(function() {
  // ...
})()

// 以数组/正则开头时
const x = 1
;[1, 2, 3].forEach(console.log)


--ts---类型声明需要特殊处理
interface Foo {
  bar: string;  // 类型成员需要分号或逗号
  baz: number,  // 也可以用逗号
}




















-----------------------------------------------------------------------------
PS D:\web3_porjs\solidity_test\hardhat2_test> npx hardhat run .\scripts\FundMe.js --network sepolia
× Help us improve Hardhat with anonymous crash reports & basic usage data? (Y/n) · y
contract deploying ...
contract has been deployed successfully, contract addresss is 0x8a737DAE61DdCB15489587e05246B3Ce1424044D
waiing for 5 confirmations
[WARNING] Network and explorer-specific api keys are deprecated in favour of the new Etherscan v2 api. Support for v1 is expected to end by May 31st, 2025. To migrate, please specify a single Etherscan.io api key the apiKey config value.
NetworkRequestError: A network request failed. This is an error from the block explorer, not Hardhat. Error: Connect Timeout Error
    at Etherscan.isVerified (D:\web3_porjs\solidity_test\hardhat2_test\node_modules\@nomicfoundation\hardhat-verify\src\internal\etherscan.ts:140:13)
    at processTicksAndRejections (node:internal/process/task_queues:105:5)
    at SimpleTaskDefinition.action (D:\web3_porjs\solidity_test\hardhat2_test\node_modules\@nomicfoundation\hardhat-verify\src\internal\tasks\etherscan.ts:108:20)
    at Environment._runTaskDefinition (D:\web3_porjs\solidity_test\hardhat2_test\node_modules\hardhat\src\internal\core\runtime-environment.ts:351:14)
    at Environment.run (D:\web3_porjs\solidity_test\hardhat2_test\node_modules\hardhat\src\internal\core\runtime-environment.ts:184:14)
    at SimpleTaskDefinition.action (D:\web3_porjs\solidity_test\hardhat2_test\node_modules\@nomicfoundation\hardhat-verify\src\index.ts:313:9)
    at Environment._runTaskDefinition (D:\web3_porjs\solidity_test\hardhat2_test\node_modules\hardhat\src\internal\core\runtime-environment.ts:351:14)
    at Environment.run (D:\web3_porjs\solidity_test\hardhat2_test\node_modules\hardhat\src\internal\core\runtime-environment.ts:184:14)
    at verifyFundMe (D:\web3_porjs\solidity_test\hardhat2_test\scripts\FundMe.js:28:5)
    at main (D:\web3_porjs\solidity_test\hardhat2_test\scripts\FundMe.js:23:5)

把 clash 中的 tun 模式开启就好了
