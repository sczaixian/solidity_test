




gas:

indexed ----  375
uint256 ----  16





IPFS
https://docs.ipfs.tech/install/ipfs-desktop/#windows


    预言机：输入预言机（链下往链上送数据）；输出预言机；计算预言机（链下执行计算任务）

    预言机是指获取、验证外部信息（即存储在链下的信息）并将外部信息传送给在区块链上运行的智能合约的应用程序
    主要解决不确定性交易达成共识问题

链上获得链下的数据或信息

提交交易，广播交易，达成共识


多节点预言机网络 DON（decentralized oracle network） 

去中心化的预言机网络


线下数据 --> data providers ---> DON ---> transmit ---> data feed contract(喂价合约) <--- 通过函数名和地址获取相应数据

链上 通过  aggregator（聚合合约）收取 链下数据  <--- 代理合约读取聚合合约  <-----  链上合约 读取代理

预言机合约是预言机服务的链上部分。 它侦听其他合约的数据请求，将数据查询转送到预言机节点，并将返回的数据广播到客户端合约。
它公开了一些函数，客户端合约在发出数据请求时调用它们


coin : 独立链，价值存储和支付；创建成本高，多属商品，用底层“燃料”
token：寄生链（如以太坊），多功能（治理/资产映射/服务访问），创建成本低，可能属性：如证券，属于应用层“工具”



-------------------------------------- 一笔交易的整个过程 -------------------------------------------------
创建交易原始数据：
    发起交易的序号 nonce 防止重放攻击，同时确保交易按顺序处理
    gasprice 为单位gas支付的费用，决定了交易处理的优先级
    gaslimit 为这笔交易支付最大gas数量
    to 收款人
    value 数额
    data 如果调用智能合约的函数，这里存放函数和参数
    chainID 区块网络编号，防止跨链重放攻击

交易签名：
    使用钱包私钥 对整个交易数据 hash （椭圆曲线数字签名算法（ECDSA））
    交易签名保证 你确实是交易发起地址的合法所有者，可以使用资金
    验证交易过程中的交易数据是否被篡改（完整、一致）


交易广播：
    钱包会把交易信息发送给它所链接的 以太坊节点，节点收到消息会进行基本检查（格式、签名、nonce等），通过后交易会存入节点的内存池
    所有的 等待交易（pending 状态）都在这里
    接下来 该节点会以同样的方式将 这笔交易广播出去，以此类推


旷工打包：
    矿工：任务是创建新的区块，它们监听 p2p 网络从内存池中搜集交易（gas出价比较高的），将一批交易组装成候选区块
    工作量证明PoW：找到满足要求的随机数，广播出去验证，然后产生一个新的区块到主链上
    权益证明PoS：被算法选中的验证者直接构建和提议区块，然后将其广播出去









npx hardhat --init

npx hardhat  查看帮助

编译：
npx hardhat build

测试：
npx hardhat test solidity
 文件包括 contract 下面的 .t.sol 文件  和  test 文件夹下的索引 .sol文件

npx hardhat test nodejs


npx hardhat run scripts/send-op-tx.ts

npx hardhat ignition deploy ignition/modules/Counter.ts


部署一般都用 ethers.js  // 文档：https://docs.ethers.org/v6/api/





npm install --save-dev hardhat-contract-sizer --legacy-peer-deps





npm install @openzeppelin/contracts --save-dev
npm install @chainlink/contracts


hardhat-config
sepolia
url:  alchemy  infura  quickNode

alchemy.com




npm update --save-dev hardhat @nomicfoundation/hardhat-verify




npm install @nomiclabs/hardhat-etherscan dotenv --save-dev


运行测试 gas 消耗量
npm install --save-dev hardhat-gas-reporter



npm install 初始化环境 根据 package.json 生成 node_models


-D  是 --save-dev 的简写
npm install -D hardhat-deploy




www.infura.io/faucet/sepolia
test git
0dcf1761eeb2457fb9412f9c4bf59642
https://mainnet.infura.io/v3/0dcf1761eeb2457fb9412f9c4bf59642


curl --url https://mainnet.infura.io/v3/0dcf1761eeb2457fb9412f9c4bf59642 \
  -X POST \
  -H "Content-Type: application/json" \
  -d '{"jsonrpc":"2.0","method":"eth_blockNumber","params":[],"id":1}'




decf550fcc469204df8d024977ad887c888a3164b0977f588ae645d3786b4511

https://dashboard.alchemy.com/?a=index
API key: RmsPYhly5O6-XH8UdmqCQ
https://eth-sepolia.g.alchemy.com/v2/RmsPYhly5O6-XH8UdmqCQ
curl 'https://eth-sepolia.g.alchemy.com/v2/RmsPYhly5O6-XH8UdmqCQ/getNFTs/?owner=vitalik.eth'




https://etherscan.io/apidashboard  apikey

TZ1JWZAT8XK1M8V4JIVD2XJGHU93GRHQ86





0x751599F0a9069D95062edb35F0078cd02BA66cC9





同质化代币就像“标准化货币”，每个代币完全一样，可以互相替换，且能分割成更小的单位
主要用于支付、交易、储蓄等金融场景，类似传统货币。

非同质化代币是“独一无二的数字资产”，每个代币不可互换，且通常不可分割
有独特标识（如编号、元数据），无法被复制或替换。
艺术品收藏、游戏资产、身份认证、版权管理等需要唯一性的场景



要明白 coin  和 token 他们的本质区别
coin ， 价值载体， 
token， 在 coin 的基础上的衍生产物

技术实现
用途
发行方式




开发者部署智能合约时，合约的字节码（编译后的代码）会通过一笔交易被打包到一个区块中，并永久存储在链上
状态更新分散在所有相关区块
智能合约的代码不会持续主动运行，而是处于“休眠”状态，直到有人通过交易调用它
通过合约地址定位定位调用


女巫攻击是指一个恶意攻击者通过创建大量的虚假身份（如节点、账户或用户名），来控制和颠覆一个分布式网络或系统的信任模型的一种攻击方式
攻击者通过技术手段（例如控制大量的僵尸电脑、使用虚拟机和不同的IP地址）伪造出成千上万的虚假身份。这样一来，攻击者就从“一个人”变成了“千军万马”，从而获得了与其实际资源不相称的巨大影响力



go与 以太坊、比特币、solana这三个交互






代币税是嵌入在智能合约中的一种机制，旨在对特定的代币交易行为自动征收一定比例的费用
作用：
    1. 创造项目收入流，也是项目的主要资金来源，可以用于项目发展费用，为项目长期发展提供燃料
    2. 奖励长期持有者，将一部分交易税以代币的形式重新分配给现有的持币者，激励长期持有而不是短期炒作，减少卖压
    3. 增强价格稳定性，增加买卖成本抑制高频交易和巨鲸的砸盘行为减缓价格变动
    4. 增加流动性深度，收入流入流动性池中，使大额交易对价格影响更小，增强代币的韧性和吸引力

合理的税率和适当的操作（奖励、资金支持、流动性注入）构建一个正向循环，可以激励价格稳步上涨，并且维持健康的流动性
如果税率过高可能会阻碍交易的活跃度，抑制流动性使得代币难以买卖最总导致恶性结果


买入税、卖出税（高于买入惩罚抛售）、转账税


通过税率实现经济目标：
    1. 刺激早增长和持有者
        高卖出税如 15% 其中10%分配给持币者，5%注入流动性池，设置较低的买入税（5%）强力锁住早期用户
    2. 为大规模营销筹集资金

    3. 维持成熟稳定
        随着代币成熟和市值增大，逐步通过社区投票降低整体税率（如从15%降至5%），
            并将税收分配重点从分红转向流动性注入和国库储备，以降低交易摩擦，吸引更大规模的资金。


Uniswap以35.9%的份额领先，PancakeSwap第二，Aerodrome和Hyperliquid增长迅速
中心化交易所：币安、Bitget、Coinbase、OKX和Bybit





-----------------------------------dex-------------------------------------------------
代表： uniswap  blur  
交易通过智能合约完成的，


1. 智能合约，满足用户交易，安全透明
2. erc20 交易量相对于 erc721更大，流动性要求更高，
    一次交易量可能更大，可能一次挂单要吃掉很多个挂单才能完成这笔交易，
    这样会消耗大量的gas（手续费很高）
    因此需要更高效的交易模式 AMM 自动化做市商模式
    智能合约自动实现用户的交易请求，管理资金池，计算价格，并且有足够的流动性保障交易进行
    没有办法通过挂单来解决，就需要引入流动性提供者LP，预先将资产放到池子中，并给出初始化定价
    交易者不需要看是否有挂单这些，直接在池子中进行买卖，价格就会跟着买卖行为自动变化，
    同时 LP 在这个过程中收取手续费



x * y = k  :  池子里放了两种 token 数量 ， 他们的乘积是固定值
随着2边数量的变动， 价格也就会发生不断变化


tick  +  tickSpacing = tick1
tick 表示一个价格
tickSpacing 表示两个 tick 中间的跨度
波动性大 会造成跨度多个 tickspacing 这样便利需要消耗更多的 gas


初始化交易池：初始化价格、初始化预言机
创建流动性：给哪个池子提供流动性  token0  和  token1  fee（费率） 这三个决定了一个池子

最后会计算出 liquidity ；通过你提供了多少 liquidity ，在整个池子中占的份额，领取手续费

调用 collect 一并将 手续费，提供流动性时的token 拿到



https://github.com/MetaNodeAcademy/Base2_Solidity_Dex/blob/main/DEX%E7%AE%80%E4%BB%8B.md
https://github.com/MetaNodeAcademy/Advanced2-contract-upgrade/blob/main/Meme%E4%BB%A3%E5%B8%81%E7%B3%BB%E5%88%97/03.%E5%90%88%E7%BA%A6%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.md
https://github.com/MetaNodeAcademy/Advanced2-contract-stake/tree/main



https://cn.rootdata.com/Projects?evalSort=2



-----------------------------solidity 语法相关----------------------------------



// 持币分红实现
function distributeDividends() public {
    uint256 contractBalance = address(this).balance;
    for (uint256 i = 0; i < shareholders.length; i++) {
        address shareholder = shareholders[i];
        uint256 share = balanceOf(shareholder) * contractBalance / totalSupply();
        payable(shareholder).transfer(share);
    }
}

在分发以太币时使用`transfer`函数，虽然`transfer`有2300gas的限制，可以防止重入攻击
循环次数限制：如果股东数量非常多，循环可能会消耗超过区块gas上限的gas，导致交易失败。这在Solidity中是一个常见问题，因为循环gas成本会随着循环次数增加而增加。
状态变量修改：在循环中对外部地址进行转账操作，如果某个地址是合约地址且其fallback函数消耗大量gas，或者故意使转账失败，则会导致整个分红操作回滚。
精度问题：在计算份额时，使用`balanceOf(shareholder) * contractBalance / totalSupply()`，如果`contractBalance`很小，而`totalSupply`很大，则可能会因为整数除法的截断导致一些股东分到的数量为0
快照问题：这个函数没有使用快照机制，如果在分红过程中有转账操作，会导致持币比例变化，从而影响分红的公平性。
权限控制：这个函数是`public`的，意味着任何人都可以调用它，可能会被恶意利用（例如，频繁调用消耗gas，或者在其他不合时宜的时候调用）



 -------------------- 修改 使用拉取模式而不是推送模式 让股东自己领取 ----------------------
mapping(address => uint256) public dividends;

function distributeDividends() public {
    uint256 contractBalance = address(this).balance;
    for (uint256 i = 0; i < shareholders.length; i++) {
        address shareholder = shareholders[i];
        uint256 share = balanceOf(shareholder) * contractBalance / totalSupply();
        dividends[shareholder] += share;
    }
}

function claimDividend() public {
    uint256 amount = dividends[msg.sender];
    require(amount > 0, "No dividends available");
    dividends[msg.sender] = 0;
    payable(msg.sender).transfer(amount);
}


------------------- 可以采用分配发送 每一轮发多少个 -----------------
uint256 public currentIndex;

function distributeDividends(uint256 batchSize) public {
    uint256 contractBalance = address(this).balance;
    uint256 endIndex = Math.min(currentIndex + batchSize, shareholders.length);
    
    for (uint256 i = currentIndex; i < endIndex; i++) {
        address shareholder = shareholders[i];
        uint256 share = balanceOf(shareholder) * contractBalance / totalSupply();
        payable(shareholder).transfer(share);
    }
    
    currentIndex = endIndex;
    if (currentIndex >= shareholders.length) {
        currentIndex = 0; // 重置索引，完成一轮分红
    }
}



// 在分红前先记录每个地址的余额快照
mapping(address => uint256) public snapshotBalance;
uint256 public snapshotTotalSupply;

function takeSnapshot() public {
    for (uint256 i = 0; i < shareholders.length; i++) {
        address shareholder = shareholders[i];
        snapshotBalance[shareholder] = balanceOf(shareholder);
    }
    snapshotTotalSupply = totalSupply();
}









----------------------- 代理合约 ----------------------------

// 代理合约核心逻辑
contract TransparentProxy {
    address private _implementation;   //  本合约要 代理的地址
    address private _admin;

    constructor(address logic) {
        _implementation = logic;
        _admin = msg.sender;
    }
    // 当合约没有匹配到函数前面会执行这个函数
    fallback() external payable {
        require(msg.sender != _admin, "Admin cannot call implementation");
        address impl = _implementation;
        assembly {
            // 当用户调用代理合约时， 调用中包含的说有信息被编码并存储在一个叫做 calldata 的特殊只读区域中
            // calldatacopy(a, b, size)  从 b 位置 搬到 a 位置，总共搬 size 个
            calldatacopy(0, 0, calldatasize())  // 将用户调用的数据复制出来
            // delegatecall 将数据原封不动的发给 impl 
            // let result 捕获的是 delegatecall本身执行的成功还是失败（1true；0false）
            // let result := delegatecall(
            //     gas(),        // 参数1: 发送的gas
            //     impl,         // 参数2: 目标合约地址
            //     0,            // 参数3: 输入数据在内存中的【起始偏移量】
            //     calldatasize(), // 参数4: 输入数据的【大小】
            //     0,            // 参数5: 输出数据在内存中的【起始偏移量】
            //     0             // 参数6: 输出数据【预留空间的大小】
            // )
            let result := delegatecall(gas(), impl, 0, calldatasize(), 0, 0)
            // 成功：返回值会被存储在 EVM 的返回数据缓冲区 (returndata buffer) 中
            // 将缓冲区中的数据复制到内存
            returndatacopy(0, 0, returndatasize())
            if iszero(result) {   // 返回0表示失败
              // 之前执行了 returndatacopy， 现在需要回滚
              revert(0, returndatasize()) 
            }
            // 将内存中的返回值返回给最初调用代理合约的地址
            return(0, returndatasize())
        }
    }
}










----------------------------------  权限控制模式  -----------------------------------
// 角色管理系统
abstract contract RBACManager {
    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;
    
    struct RoleData {
        mapping(address => bool) members;
        bytes32 adminRole;
    }

    mapping(bytes32 => RoleData) private _roles;
    
    event RoleGranted(bytes32 indexed role, address indexed account);
    event RoleRevoked(bytes32 indexed role, address indexed account);

    // 分层权限校验
    modifier onlyRole(bytes32 role) {
        _checkRole(role, msg.sender);
        _;
    }

    function _checkRole(bytes32 role, address account) internal view {
        if (!hasRole(role, account)) {
            revert(string(abi.encodePacked(
                "AccessControl: account ",
                Strings.toHexString(account),
                " is missing role ",
                Strings.toHexString(uint256(role), 32)
            )));
        }
    }

    // 带继承关系的角色管理
    function grantRole(bytes32 role, address account) 
        public virtual onlyRole(getRoleAdmin(role)) 
    {
        _grantRole(role, account);
    }
    
    function _grantRole(bytes32 role, address account) internal {
        if (!hasRole(role, account)) {
            _roles[role].members[account] = true;
            emit RoleGranted(role, account, msg.sender);
        }
    }
}






UUPS 模式核心思想
在以太坊中，合约一旦部署，其代码就是不可变的。为了实现逻辑升级，我们采用了“代理-实现”模式
代理合约存储状态数据，不包含核心逻辑
实现合约：实现业务逻辑，不存储持久状态

// UUPS 升级逻辑实现
abstract contract UUPSUpgradeable {
    function upgradeTo(address newImplementation) external virtual {
        _authorizeUpgrade(newImplementation);
        _upgradeTo(newImplementation);
    }

    function _authorizeUpgrade(address) internal virtual;
}

contract MyToken is UUPSUpgradeable {  // 要升级的合约集成 
    // 实现授权逻辑
    function _authorizeUpgrade(address) internal override onlyOwner {}
}







-------------------------- 可以转换为 address 类型 -------------------------------

// 合约定义
contract MyContract {}

// 转换为address
MyContract c = new MyContract();
address addr = address(c);



// 整数类型（uint160）
uint160 value = 123456789;
address addr = address(value);


// 地址字面量
address addr = 0x5B38Da6a701c568545dCfcB03FcB875f56beddC4;



CREATE2 它允许您根据  部署者控制的参数（加盐） 将智能合约部署到确定性地址。

address(new Pool{salt: salt}())表达式用于
使用CREATE2操作码部署一个新合约
通过指定的salt值确定合约地址
将新部署的合约实例转换为address类型
注意：使用CREATE2可以通过salt预先计算合约地址，这对于状态通道和链下交易等应用非常有用


// 计算CREATE2地址的Solidity代码
function computeAddress(bytes32 salt, bytes32 bytecodeHash) public view returns (address) {
	return address(
  		uint160(
  			uint256(
    			keccak256(
    				abi.encodePacked(bytes1(0xff), address(this), salt, bytecodeHash)
    			)
  			)
  		)
  	);
}






-----------------------------js  ts 语法相关----------------------------------
// 立即执行函数
;(function() {
  // ...
})()

// 以数组/正则开头时
const x = 1
;[1, 2, 3].forEach(console.log)


--ts---类型声明需要特殊处理
interface Foo {
  bar: string;  // 类型成员需要分号或逗号
  baz: number,  // 也可以用逗号
}




















-----------------------------------------------------------------------------
PS D:\web3_porjs\solidity_test\hardhat2_test> npx hardhat run .\scripts\FundMe.js --network sepolia
× Help us improve Hardhat with anonymous crash reports & basic usage data? (Y/n) · y
contract deploying ...
contract has been deployed successfully, contract addresss is 0x8a737DAE61DdCB15489587e05246B3Ce1424044D
waiing for 5 confirmations
[WARNING] Network and explorer-specific api keys are deprecated in favour of the new Etherscan v2 api. Support for v1 is expected to end by May 31st, 2025. To migrate, please specify a single Etherscan.io api key the apiKey config value.
NetworkRequestError: A network request failed. This is an error from the block explorer, not Hardhat. Error: Connect Timeout Error
    at Etherscan.isVerified (D:\web3_porjs\solidity_test\hardhat2_test\node_modules\@nomicfoundation\hardhat-verify\src\internal\etherscan.ts:140:13)
    at processTicksAndRejections (node:internal/process/task_queues:105:5)
    at SimpleTaskDefinition.action (D:\web3_porjs\solidity_test\hardhat2_test\node_modules\@nomicfoundation\hardhat-verify\src\internal\tasks\etherscan.ts:108:20)
    at Environment._runTaskDefinition (D:\web3_porjs\solidity_test\hardhat2_test\node_modules\hardhat\src\internal\core\runtime-environment.ts:351:14)
    at Environment.run (D:\web3_porjs\solidity_test\hardhat2_test\node_modules\hardhat\src\internal\core\runtime-environment.ts:184:14)
    at SimpleTaskDefinition.action (D:\web3_porjs\solidity_test\hardhat2_test\node_modules\@nomicfoundation\hardhat-verify\src\index.ts:313:9)
    at Environment._runTaskDefinition (D:\web3_porjs\solidity_test\hardhat2_test\node_modules\hardhat\src\internal\core\runtime-environment.ts:351:14)
    at Environment.run (D:\web3_porjs\solidity_test\hardhat2_test\node_modules\hardhat\src\internal\core\runtime-environment.ts:184:14)
    at verifyFundMe (D:\web3_porjs\solidity_test\hardhat2_test\scripts\FundMe.js:28:5)
    at main (D:\web3_porjs\solidity_test\hardhat2_test\scripts\FundMe.js:23:5)

把 clash 中的 tun 模式开启就好了













---------------------------------- pledge --------------------------------------------------
PS D:\web3_porjs\pledge\pledgev2> npx hardhat run scripts/deploy/multiSignature.js --network sepolia
Deploying contracts with the account: 0x3E0bDb54f94D735dDCf8D2074c852a8C22914aA7
Account balance: 3533590637853159752
multiSignature address: 0xf2870D6cd715F1b7EfeDbABC26564b41c043F3ef



let multiSignatureAddress = ["0x3E0bDb54f94D735dDCf8D2074c852a8C22914aA7",
                            "0xd96AF416b2060500f828A3f31e617F15CBEA1e4b",
                            "0x1984EE3bCE0c863d24905dF9D54322856e54CCea"];



PS D:\web3_porjs\pledge\pledgev2> npx hardhat run scripts/deploy/debtToken.js --network sepolia
Deploying contracts with the account: 0x3E0bDb54f94D735dDCf8D2074c852a8C22914aA7
Account balance: 3533589615997684278
DebtToken address: 0x46E6B2F8aBDD166F1B293d5A30CC1Ec5578E85e6                            




PS D:\web3_porjs\pledge\pledgev2> npx hardhat run scripts/deploy/swapRouter.js --network sepolia
router 0xF56B74461BAf8b92A6a63D8e163ae409913Da237
factory 0xCc65694dC4D5084A609Be51004Cd3f75ef50bC9B




PS D:\web3_porjs\pledge\pledgev2> npx hardhat run scripts/deploy/pledgePool.js --network sepolia
Deploying contracts with the account: 0x3E0bDb54f94D735dDCf8D2074c852a8C22914aA7
Account balance: 3533578144983471160
pledgeAddress address: 0x5ad3AfddAaE25fdC2D85A3aC607D444F1c515f05




pnpm install ajv@7.2.3 ajv-formats@2.1.1 --save-dev



---------------pledge\pledge-fe\src\utils\getTokenList.ts-------------
import { TokenList } from '@uniswap/token-lists'
import schema from '@uniswap/token-lists/src/tokenlist.schema.json'
import Ajv from 'ajv'
import contenthashToUri from './contenthashToUri'
import { parseENSAddress } from './parseENSAddress'
import uriToHttp from './uriToHttp'
import addFormats from 'ajv-formats'

// bakeryswap defaultTokenJson
import { DEFAULT_TOKEN_LIST_URL } from '../constants/lists'
import defaultTokenJson from '../constants/token/pancakeswap.json'

// 创建 Ajv 实例
const ajv = new Ajv({ allErrors: true })
// 使用 addFormats 来扩展这个实例，使其支持格式验证（如 date-time 等）
addFormats(ajv)
// 然后编译 schema
const tokenListValidator = ajv.compile(schema)







-------------------------------------- EVM -------------------------------------------------

virtual ROM( 只能合约代码，只读 )
machine state 相当于RAM，一种易失性的存储器，执行完清除
wrold state 有合约的状态变量存储的地方，这部分数据是永久存储在区块链上的数据

---- memory ----
EVM内存是线性存储的，可以实现字节级别的寻址。它用于存储临时变量和一些动态大小的数组。solidity可以使用memory来声明内存变量。

内存的字宽是8位。内存一次能读取为256位，而内存一次写入可以为8位或256位。内联汇编能够使用 MSTORE、MSTORE8、MLOAD指令操作memory。



---- calldata ----
calldata是一个不限制大小的字节数组，用来指定消息调用的输入数据(这个输入数据是指Massage Call输入的data。calldata与内存不同，是一段只读的可寻址的保存函数调用参数的空间。

前四字节是函数选择器。
其余字节是函数输入参数， 每个输入参数长度为32字节。小于32字节的参数会被填充到32字节长度

对calldata操作的指令有三个：
    calldatasize：返回calldata的大小。
    calldataload：从calldata中加载32bytes到stack中。
    calldatacopy：拷贝一些字节到内存中。







function registerUser(string calldata _name) external returns (uint256)
对于 external函数中的引用类型参数（如 string, array, bytes），使用 calldata是更佳选择，主要原因在于 Gas 优化和语义明确。    