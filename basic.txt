




gas:

indexed ----  375
uint256 ----  16





IPFS
https://docs.ipfs.tech/install/ipfs-desktop/#windows


    预言机：输入预言机（链下往链上送数据）；输出预言机；计算预言机（链下执行计算任务）

    预言机是指获取、验证外部信息（即存储在链下的信息）并将外部信息传送给在区块链上运行的智能合约的应用程序
    主要解决不确定性交易达成共识问题

链上获得链下的数据或信息

提交交易，广播交易，达成共识


多节点预言机网络 DON（decentralized oracle network） 

去中心化的预言机网络


线下数据 --> data providers ---> DON ---> transmit ---> data feed contract(喂价合约) <--- 通过函数名和地址获取相应数据

链上 通过  aggregator（聚合合约）收取 链下数据  <--- 代理合约读取聚合合约  <-----  链上合约 读取代理

预言机合约是预言机服务的链上部分。 它侦听其他合约的数据请求，将数据查询转送到预言机节点，并将返回的数据广播到客户端合约。
它公开了一些函数，客户端合约在发出数据请求时调用它们


coin : 独立链，价值存储和支付；创建成本高，多属商品，用底层“燃料”
token：寄生链（如以太坊），多功能（治理/资产映射/服务访问），创建成本低，可能属性：如证券，属于应用层“工具”










npx hardhat --init

npx hardhat  查看帮助

编译：
npx hardhat build

测试：
npx hardhat test solidity
 文件包括 contract 下面的 .t.sol 文件  和  test 文件夹下的索引 .sol文件

npx hardhat test nodejs


npx hardhat run scripts/send-op-tx.ts

npx hardhat ignition deploy ignition/modules/Counter.ts


部署一般都用 ethers.js  // 文档：https://docs.ethers.org/v6/api/





npm install --save-dev hardhat-contract-sizer --legacy-peer-deps





npm install @openzeppelin/contracts --save-dev
npm install @chainlink/contracts


hardhat-config
sepolia
url:  alchemy  infura  quickNode

alchemy.com




npm update --save-dev hardhat @nomicfoundation/hardhat-verify




npm install @nomiclabs/hardhat-etherscan dotenv --save-dev


运行测试 gas 消耗量
npm install --save-dev hardhat-gas-reporter



npm install 初始化环境 根据 package.json 生成 node_models


-D  是 --save-dev 的简写
npm install -D hardhat-deploy




www.infura.io/faucet/sepolia
test git
0dcf1761eeb2457fb9412f9c4bf59642
https://mainnet.infura.io/v3/0dcf1761eeb2457fb9412f9c4bf59642


curl --url https://mainnet.infura.io/v3/0dcf1761eeb2457fb9412f9c4bf59642 \
  -X POST \
  -H "Content-Type: application/json" \
  -d '{"jsonrpc":"2.0","method":"eth_blockNumber","params":[],"id":1}'




decf550fcc469204df8d024977ad887c888a3164b0977f588ae645d3786b4511

https://dashboard.alchemy.com/?a=index
API key: RmsPYhly5O6-XH8UdmqCQ
https://eth-sepolia.g.alchemy.com/v2/RmsPYhly5O6-XH8UdmqCQ
curl 'https://eth-sepolia.g.alchemy.com/v2/RmsPYhly5O6-XH8UdmqCQ/getNFTs/?owner=vitalik.eth'




https://etherscan.io/apidashboard  apikey

TZ1JWZAT8XK1M8V4JIVD2XJGHU93GRHQ86





0x751599F0a9069D95062edb35F0078cd02BA66cC9





同质化代币就像“标准化货币”，每个代币完全一样，可以互相替换，且能分割成更小的单位
主要用于支付、交易、储蓄等金融场景，类似传统货币。

非同质化代币是“独一无二的数字资产”，每个代币不可互换，且通常不可分割
有独特标识（如编号、元数据），无法被复制或替换。
艺术品收藏、游戏资产、身份认证、版权管理等需要唯一性的场景



要明白 coin  和 token 他们的本质区别
coin ， 价值载体， 
token， 在 coin 的基础上的衍生产物

技术实现
用途
发行方式




开发者部署智能合约时，合约的​​字节码（编译后的代码）​​会通过一笔交易被打包到一个区块中，并永久存储在链上
状态更新分散在所有相关区块
智能合约的代码​​不会持续主动运行​​，而是处于“休眠”状态，直到有人通过交易调用它
通过合约地址定位定位调用


女巫攻击是指一个恶意攻击者通过创建大量的虚假身份（如节点、账户或用户名），来控制和颠覆一个分布式网络或系统的信任模型的一种攻击方式
攻击者通过技术手段（例如控制大量的僵尸电脑、使用虚拟机和不同的IP地址）伪造出成千上万的虚假身份。这样一来，攻击者就从“一个人”变成了“千军万马”，从而获得了与其实际资源不相称的巨大影响力



go与 以太坊、比特币、solana这三个交互






代币税是嵌入在智能合约中的一种机制，旨在对特定的代币交易行为自动征收一定比例的费用
作用：
    1. 创造项目收入流，也是项目的主要资金来源，可以用于项目发展费用，为项目长期发展提供燃料
    2. 奖励长期持有者，将一部分交易税以代币的形式重新分配给现有的持币者，激励长期持有而不是短期炒作，减少卖压
    3. 增强价格稳定性，增加买卖成本抑制高频交易和巨鲸的砸盘行为减缓价格变动
    4. 增加流动性深度，收入流入流动性池中，使大额交易对价格影响更小，增强代币的韧性和吸引力

合理的税率和适当的操作（奖励、资金支持、流动性注入）构建一个正向循环，可以激励价格稳步上涨，并且维持健康的流动性
如果税率过高可能会阻碍交易的活跃度，抑制流动性使得代币难以买卖最总导致恶性结果


买入税、卖出税（高于买入惩罚抛售）、转账税


通过税率实现经济目标：
    1. 刺激早增长和持有者
        高卖出税如 15% 其中10%分配给持币者，5%注入流动性池，设置较低的买入税（5%）强力锁住早期用户
    2. 为大规模营销筹集资金

    3. 维持成熟稳定
        随着代币成熟和市值增大，逐步通过社区投票降低整体税率（如从15%降至5%），
            并将税收分配重点从分红转向流动性注入和国库储备，以降低交易摩擦，吸引更大规模的资金。


Uniswap以35.9%的份额领先，PancakeSwap第二，Aerodrome和Hyperliquid增长迅速
中心化交易所：币安、Bitget、Coinbase、OKX和Bybit


-----------------------------------dex-------------------------------------------------
代表： uniswap  blur  
交易通过智能合约完成的，


1. 智能合约，满足用户交易，安全透明
2. erc20 交易量相对于 erc721更大，流动性要求更高，
    一次交易量可能更大，可能一次挂单要吃掉很多个挂单才能完成这笔交易，
    这样会消耗大量的gas（手续费很高）
    因此需要更高效的交易模式 AMM 自动化做市商模式
    智能合约自动实现用户的交易请求，管理资金池，计算价格，并且有足够的流动性保障交易进行
    没有办法通过挂单来解决，就需要引入流动性提供者LP，预先将资产放到池子中，并给出初始化定价
    交易者不需要看是否有挂单这些，直接在池子中进行买卖，价格就会跟着买卖行为自动变化，
    同时 LP 在这个过程中收取手续费



x * y = k  :  池子里放了两种 token 数量 ， 他们的乘积是固定值
随着2边数量的变动， 价格也就会发生不断变化


tick  +  tickSpacing = tick1
tick 表示一个价格
tickSpacing 表示两个 tick 中间的跨度
波动性大 会造成跨度多个 tickspacing 这样便利需要消耗更多的 gas


初始化交易池：初始化价格、初始化预言机
创建流动性：给哪个池子提供流动性  token0  和  token1  fee（费率） 这三个决定了一个池子

最后会计算出 liquidity ；通过你提供了多少 liquidity ，在整个池子中占的份额，领取手续费

调用 collect 一并将 手续费，提供流动性时的token 拿到



https://github.com/MetaNodeAcademy/Base2_Solidity_Dex/blob/main/DEX%E7%AE%80%E4%BB%8B.md
https://github.com/MetaNodeAcademy/Advanced2-contract-upgrade/blob/main/Meme%E4%BB%A3%E5%B8%81%E7%B3%BB%E5%88%97/03.%E5%90%88%E7%BA%A6%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.md
https://github.com/MetaNodeAcademy/Advanced2-contract-stake/tree/main



https://cn.rootdata.com/Projects?evalSort=2



-----------------------------solidity 语法相关----------------------------------



// 持币分红实现
function distributeDividends() public {
    uint256 contractBalance = address(this).balance;
    for (uint256 i = 0; i < shareholders.length; i++) {
        address shareholder = shareholders[i];
        uint256 share = balanceOf(shareholder) * contractBalance / totalSupply();
        payable(shareholder).transfer(share);
    }
}

在分发以太币时使用`transfer`函数，虽然`transfer`有2300gas的限制，可以防止重入攻击
循环次数限制：如果股东数量非常多，循环可能会消耗超过区块gas上限的gas，导致交易失败。这在Solidity中是一个常见问题，因为循环gas成本会随着循环次数增加而增加。
状态变量修改：在循环中对外部地址进行转账操作，如果某个地址是合约地址且其fallback函数消耗大量gas，或者故意使转账失败，则会导致整个分红操作回滚。
精度问题：在计算份额时，使用`balanceOf(shareholder) * contractBalance / totalSupply()`，如果`contractBalance`很小，而`totalSupply`很大，则可能会因为整数除法的截断导致一些股东分到的数量为0
快照问题：这个函数没有使用快照机制，如果在分红过程中有转账操作，会导致持币比例变化，从而影响分红的公平性。
权限控制：这个函数是`public`的，意味着任何人都可以调用它，可能会被恶意利用（例如，频繁调用消耗gas，或者在其他不合时宜的时候调用）



 -------------------- 修改 使用拉取模式而不是推送模式 让股东自己领取 ----------------------
mapping(address => uint256) public dividends;

function distributeDividends() public {
    uint256 contractBalance = address(this).balance;
    for (uint256 i = 0; i < shareholders.length; i++) {
        address shareholder = shareholders[i];
        uint256 share = balanceOf(shareholder) * contractBalance / totalSupply();
        dividends[shareholder] += share;
    }
}

function claimDividend() public {
    uint256 amount = dividends[msg.sender];
    require(amount > 0, "No dividends available");
    dividends[msg.sender] = 0;
    payable(msg.sender).transfer(amount);
}


------------------- 可以采用分配发送 每一轮发多少个 -----------------
uint256 public currentIndex;

function distributeDividends(uint256 batchSize) public {
    uint256 contractBalance = address(this).balance;
    uint256 endIndex = Math.min(currentIndex + batchSize, shareholders.length);
    
    for (uint256 i = currentIndex; i < endIndex; i++) {
        address shareholder = shareholders[i];
        uint256 share = balanceOf(shareholder) * contractBalance / totalSupply();
        payable(shareholder).transfer(share);
    }
    
    currentIndex = endIndex;
    if (currentIndex >= shareholders.length) {
        currentIndex = 0; // 重置索引，完成一轮分红
    }
}



// 在分红前先记录每个地址的余额快照
mapping(address => uint256) public snapshotBalance;
uint256 public snapshotTotalSupply;

function takeSnapshot() public {
    for (uint256 i = 0; i < shareholders.length; i++) {
        address shareholder = shareholders[i];
        snapshotBalance[shareholder] = balanceOf(shareholder);
    }
    snapshotTotalSupply = totalSupply();
}









----------------------- 代理合约 ----------------------------

// 代理合约核心逻辑
contract TransparentProxy {
    address private _implementation;   //  本合约要 代理的地址
    address private _admin;

    constructor(address logic) {
        _implementation = logic;
        _admin = msg.sender;
    }
    // 当合约没有匹配到函数前面会执行这个函数
    fallback() external payable {
        require(msg.sender != _admin, "Admin cannot call implementation");
        address impl = _implementation;
        assembly {
            // 当用户调用代理合约时， 调用中包含的说有信息被编码并存储在一个叫做 calldata 的特殊只读区域中
            // calldatacopy(a, b, size)  从 b 位置 搬到 a 位置，总共搬 size 个
            calldatacopy(0, 0, calldatasize())  // 将用户调用的数据复制出来
            // delegatecall 将数据原封不动的发给 impl 
            // let result 捕获的是 delegatecall本身执行的成功还是失败（1true；0false）
            // let result := delegatecall(
            //     gas(),        // 参数1: 发送的gas
            //     impl,         // 参数2: 目标合约地址
            //     0,            // 参数3: 输入数据在内存中的【起始偏移量】
            //     calldatasize(), // 参数4: 输入数据的【大小】
            //     0,            // 参数5: 输出数据在内存中的【起始偏移量】
            //     0             // 参数6: 输出数据【预留空间的大小】
            // )
            let result := delegatecall(gas(), impl, 0, calldatasize(), 0, 0)
            // 成功：返回值会被存储在 EVM 的返回数据缓冲区 (returndata buffer) 中
            // 将缓冲区中的数据复制到内存
            returndatacopy(0, 0, returndatasize())
            if iszero(result) {   // 返回0表示失败
              // 之前执行了 returndatacopy， 现在需要回滚
              revert(0, returndatasize()) 
            }
            // 将内存中的返回值返回给最初调用代理合约的地址
            return(0, returndatasize())
        }
    }
}










----------------------------------  权限控制模式  -----------------------------------
// 角色管理系统
abstract contract RBACManager {
    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;
    
    struct RoleData {
        mapping(address => bool) members;
        bytes32 adminRole;
    }

    mapping(bytes32 => RoleData) private _roles;
    
    event RoleGranted(bytes32 indexed role, address indexed account);
    event RoleRevoked(bytes32 indexed role, address indexed account);

    // 分层权限校验
    modifier onlyRole(bytes32 role) {
        _checkRole(role, msg.sender);
        _;
    }

    function _checkRole(bytes32 role, address account) internal view {
        if (!hasRole(role, account)) {
            revert(string(abi.encodePacked(
                "AccessControl: account ",
                Strings.toHexString(account),
                " is missing role ",
                Strings.toHexString(uint256(role), 32)
            )));
        }
    }

    // 带继承关系的角色管理
    function grantRole(bytes32 role, address account) 
        public virtual onlyRole(getRoleAdmin(role)) 
    {
        _grantRole(role, account);
    }
    
    function _grantRole(bytes32 role, address account) internal {
        if (!hasRole(role, account)) {
            _roles[role].members[account] = true;
            emit RoleGranted(role, account, msg.sender);
        }
    }
}






UUPS 模式核心思想
在以太坊中，合约一旦部署，其代码就是不可变的。为了实现逻辑升级，我们采用了“代理-实现”模式
代理合约存储状态数据，不包含核心逻辑
实现合约：实现业务逻辑，不存储持久状态

// UUPS 升级逻辑实现
abstract contract UUPSUpgradeable {
    function upgradeTo(address newImplementation) external virtual {
        _authorizeUpgrade(newImplementation);
        _upgradeTo(newImplementation);
    }

    function _authorizeUpgrade(address) internal virtual;
}

contract MyToken is UUPSUpgradeable {  // 要升级的合约集成 
    // 实现授权逻辑
    function _authorizeUpgrade(address) internal override onlyOwner {}
}













-----------------------------js  ts 语法相关----------------------------------
// 立即执行函数
;(function() {
  // ...
})()

// 以数组/正则开头时
const x = 1
;[1, 2, 3].forEach(console.log)


--ts---类型声明需要特殊处理
interface Foo {
  bar: string;  // 类型成员需要分号或逗号
  baz: number,  // 也可以用逗号
}




















-----------------------------------------------------------------------------
PS D:\web3_porjs\solidity_test\hardhat2_test> npx hardhat run .\scripts\FundMe.js --network sepolia
× Help us improve Hardhat with anonymous crash reports & basic usage data? (Y/n) · y
contract deploying ...
contract has been deployed successfully, contract addresss is 0x8a737DAE61DdCB15489587e05246B3Ce1424044D
waiing for 5 confirmations
[WARNING] Network and explorer-specific api keys are deprecated in favour of the new Etherscan v2 api. Support for v1 is expected to end by May 31st, 2025. To migrate, please specify a single Etherscan.io api key the apiKey config value.
NetworkRequestError: A network request failed. This is an error from the block explorer, not Hardhat. Error: Connect Timeout Error
    at Etherscan.isVerified (D:\web3_porjs\solidity_test\hardhat2_test\node_modules\@nomicfoundation\hardhat-verify\src\internal\etherscan.ts:140:13)
    at processTicksAndRejections (node:internal/process/task_queues:105:5)
    at SimpleTaskDefinition.action (D:\web3_porjs\solidity_test\hardhat2_test\node_modules\@nomicfoundation\hardhat-verify\src\internal\tasks\etherscan.ts:108:20)
    at Environment._runTaskDefinition (D:\web3_porjs\solidity_test\hardhat2_test\node_modules\hardhat\src\internal\core\runtime-environment.ts:351:14)
    at Environment.run (D:\web3_porjs\solidity_test\hardhat2_test\node_modules\hardhat\src\internal\core\runtime-environment.ts:184:14)
    at SimpleTaskDefinition.action (D:\web3_porjs\solidity_test\hardhat2_test\node_modules\@nomicfoundation\hardhat-verify\src\index.ts:313:9)
    at Environment._runTaskDefinition (D:\web3_porjs\solidity_test\hardhat2_test\node_modules\hardhat\src\internal\core\runtime-environment.ts:351:14)
    at Environment.run (D:\web3_porjs\solidity_test\hardhat2_test\node_modules\hardhat\src\internal\core\runtime-environment.ts:184:14)
    at verifyFundMe (D:\web3_porjs\solidity_test\hardhat2_test\scripts\FundMe.js:28:5)
    at main (D:\web3_porjs\solidity_test\hardhat2_test\scripts\FundMe.js:23:5)

把 clash 中的 tun 模式开启就好了
