


代币税是嵌入在智能合约中的一种机制，旨在对特定的代币交易行为自动征收一定比例的费用
作用：
    1. 创造项目收入流，也是项目的主要资金来源，可以用于项目发展费用，为项目长期发展提供燃料
    2. 奖励长期持有者，将一部分交易税以代币的形式重新分配给现有的持币者，激励长期持有而不是短期炒作，减少卖压
    3. 增强价格稳定性，增加买卖成本抑制高频交易和巨鲸的砸盘行为减缓价格变动
    4. 增加流动性深度，收入流入流动性池中，使大额交易对价格影响更小，增强代币的韧性和吸引力

合理的税率和适当的操作（奖励、资金支持、流动性注入）构建一个正向循环，可以激励价格稳步上涨，并且维持健康的流动性
如果税率过高可能会阻碍交易的活跃度，抑制流动性使得代币难以买卖最总导致恶性结果


买入税、卖出税（高于买入惩罚抛售）、转账税


通过税率实现经济目标：
    1. 刺激早增长和持有者
        高卖出税如 15% 其中10%分配给持币者，5%注入流动性池，设置较低的买入税（5%）强力锁住早期用户
    2. 为大规模营销筹集资金

    3. 维持成熟稳定
        随着代币成熟和市值增大，逐步通过社区投票降低整体税率（如从15%降至5%），
            并将税收分配重点从分红转向流动性注入和国库储备，以降低交易摩擦，吸引更大规模的资金。





UUPS 模式核心思想
在以太坊中，合约一旦部署，其代码就是不可变的。为了实现逻辑升级，我们采用了“代理-实现”模式
代理合约存储状态数据，不包含核心逻辑
实现合约：实现业务逻辑，不存储持久状态

// UUPS 升级逻辑实现
abstract contract UUPSUpgradeable {
    function upgradeTo(address newImplementation) external virtual {
        _authorizeUpgrade(newImplementation);
        _upgradeTo(newImplementation);
    }

    function _authorizeUpgrade(address) internal virtual;
}

contract MyToken is UUPSUpgradeable {  // 要升级的合约集成 
    // 实现授权逻辑
    function _authorizeUpgrade(address) internal override onlyOwner {}
}



















----------------------------------  权限控制模式  -----------------------------------
// 角色管理系统
abstract contract RBACManager {
    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;
    
    struct RoleData {
        mapping(address => bool) members;
        bytes32 adminRole;
    }

    mapping(bytes32 => RoleData) private _roles;
    
    event RoleGranted(bytes32 indexed role, address indexed account);
    event RoleRevoked(bytes32 indexed role, address indexed account);

    // 分层权限校验
    modifier onlyRole(bytes32 role) {
        _checkRole(role, msg.sender);
        _;
    }

    function _checkRole(bytes32 role, address account) internal view {
        if (!hasRole(role, account)) {
            revert(string(abi.encodePacked(
                "AccessControl: account ",
                Strings.toHexString(account),
                " is missing role ",
                Strings.toHexString(uint256(role), 32)
            )));
        }
    }

    // 带继承关系的角色管理
    function grantRole(bytes32 role, address account) 
        public virtual onlyRole(getRoleAdmin(role)) 
    {
        _grantRole(role, account);
    }
    
    function _grantRole(bytes32 role, address account) internal {
        if (!hasRole(role, account)) {
            _roles[role].members[account] = true;
            emit RoleGranted(role, account, msg.sender);
        }
    }
}